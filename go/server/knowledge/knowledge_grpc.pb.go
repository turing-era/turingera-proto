// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.8
// source: knowledge.proto

package knowledge

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// KnowledgeSvrClient is the client API for KnowledgeSvr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KnowledgeSvrClient interface {
	// 获取知识列表
	GetKnowledgeList(ctx context.Context, in *GetKnowledgeListReq, opts ...grpc.CallOption) (*GetKnowledgeListRsp, error)
	// 保存知识资料
	SaveKnowledge(ctx context.Context, in *SaveKnowledgeReq, opts ...grpc.CallOption) (*SaveKnowledgeRsp, error)
	// 删除知识资料
	RemKnowledge(ctx context.Context, in *RemKnowledgeReq, opts ...grpc.CallOption) (*RemKnowledgeRsp, error)
	// 加载知识库
	LoadKnowledge(ctx context.Context, in *LoadKnowledgeReq, opts ...grpc.CallOption) (*LoadKnowledgeRsp, error)
	// 搜索知识库
	SearchKnowledge(ctx context.Context, in *SearchKnowledgeReq, opts ...grpc.CallOption) (*SearchKnowledgeRsp, error)
}

type knowledgeSvrClient struct {
	cc grpc.ClientConnInterface
}

func NewKnowledgeSvrClient(cc grpc.ClientConnInterface) KnowledgeSvrClient {
	return &knowledgeSvrClient{cc}
}

func (c *knowledgeSvrClient) GetKnowledgeList(ctx context.Context, in *GetKnowledgeListReq, opts ...grpc.CallOption) (*GetKnowledgeListRsp, error) {
	out := new(GetKnowledgeListRsp)
	err := c.cc.Invoke(ctx, "/turingera.server.knowledge.KnowledgeSvr/GetKnowledgeList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeSvrClient) SaveKnowledge(ctx context.Context, in *SaveKnowledgeReq, opts ...grpc.CallOption) (*SaveKnowledgeRsp, error) {
	out := new(SaveKnowledgeRsp)
	err := c.cc.Invoke(ctx, "/turingera.server.knowledge.KnowledgeSvr/SaveKnowledge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeSvrClient) RemKnowledge(ctx context.Context, in *RemKnowledgeReq, opts ...grpc.CallOption) (*RemKnowledgeRsp, error) {
	out := new(RemKnowledgeRsp)
	err := c.cc.Invoke(ctx, "/turingera.server.knowledge.KnowledgeSvr/RemKnowledge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeSvrClient) LoadKnowledge(ctx context.Context, in *LoadKnowledgeReq, opts ...grpc.CallOption) (*LoadKnowledgeRsp, error) {
	out := new(LoadKnowledgeRsp)
	err := c.cc.Invoke(ctx, "/turingera.server.knowledge.KnowledgeSvr/LoadKnowledge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeSvrClient) SearchKnowledge(ctx context.Context, in *SearchKnowledgeReq, opts ...grpc.CallOption) (*SearchKnowledgeRsp, error) {
	out := new(SearchKnowledgeRsp)
	err := c.cc.Invoke(ctx, "/turingera.server.knowledge.KnowledgeSvr/SearchKnowledge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KnowledgeSvrServer is the server API for KnowledgeSvr service.
// All implementations must embed UnimplementedKnowledgeSvrServer
// for forward compatibility
type KnowledgeSvrServer interface {
	// 获取知识列表
	GetKnowledgeList(context.Context, *GetKnowledgeListReq) (*GetKnowledgeListRsp, error)
	// 保存知识资料
	SaveKnowledge(context.Context, *SaveKnowledgeReq) (*SaveKnowledgeRsp, error)
	// 删除知识资料
	RemKnowledge(context.Context, *RemKnowledgeReq) (*RemKnowledgeRsp, error)
	// 加载知识库
	LoadKnowledge(context.Context, *LoadKnowledgeReq) (*LoadKnowledgeRsp, error)
	// 搜索知识库
	SearchKnowledge(context.Context, *SearchKnowledgeReq) (*SearchKnowledgeRsp, error)
	mustEmbedUnimplementedKnowledgeSvrServer()
}

// UnimplementedKnowledgeSvrServer must be embedded to have forward compatible implementations.
type UnimplementedKnowledgeSvrServer struct {
}

func (UnimplementedKnowledgeSvrServer) GetKnowledgeList(context.Context, *GetKnowledgeListReq) (*GetKnowledgeListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKnowledgeList not implemented")
}
func (UnimplementedKnowledgeSvrServer) SaveKnowledge(context.Context, *SaveKnowledgeReq) (*SaveKnowledgeRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveKnowledge not implemented")
}
func (UnimplementedKnowledgeSvrServer) RemKnowledge(context.Context, *RemKnowledgeReq) (*RemKnowledgeRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemKnowledge not implemented")
}
func (UnimplementedKnowledgeSvrServer) LoadKnowledge(context.Context, *LoadKnowledgeReq) (*LoadKnowledgeRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadKnowledge not implemented")
}
func (UnimplementedKnowledgeSvrServer) SearchKnowledge(context.Context, *SearchKnowledgeReq) (*SearchKnowledgeRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchKnowledge not implemented")
}
func (UnimplementedKnowledgeSvrServer) mustEmbedUnimplementedKnowledgeSvrServer() {}

// UnsafeKnowledgeSvrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KnowledgeSvrServer will
// result in compilation errors.
type UnsafeKnowledgeSvrServer interface {
	mustEmbedUnimplementedKnowledgeSvrServer()
}

func RegisterKnowledgeSvrServer(s grpc.ServiceRegistrar, srv KnowledgeSvrServer) {
	s.RegisterService(&KnowledgeSvr_ServiceDesc, srv)
}

func _KnowledgeSvr_GetKnowledgeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKnowledgeListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeSvrServer).GetKnowledgeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/turingera.server.knowledge.KnowledgeSvr/GetKnowledgeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeSvrServer).GetKnowledgeList(ctx, req.(*GetKnowledgeListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KnowledgeSvr_SaveKnowledge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveKnowledgeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeSvrServer).SaveKnowledge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/turingera.server.knowledge.KnowledgeSvr/SaveKnowledge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeSvrServer).SaveKnowledge(ctx, req.(*SaveKnowledgeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KnowledgeSvr_RemKnowledge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemKnowledgeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeSvrServer).RemKnowledge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/turingera.server.knowledge.KnowledgeSvr/RemKnowledge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeSvrServer).RemKnowledge(ctx, req.(*RemKnowledgeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KnowledgeSvr_LoadKnowledge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadKnowledgeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeSvrServer).LoadKnowledge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/turingera.server.knowledge.KnowledgeSvr/LoadKnowledge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeSvrServer).LoadKnowledge(ctx, req.(*LoadKnowledgeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KnowledgeSvr_SearchKnowledge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchKnowledgeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeSvrServer).SearchKnowledge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/turingera.server.knowledge.KnowledgeSvr/SearchKnowledge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeSvrServer).SearchKnowledge(ctx, req.(*SearchKnowledgeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// KnowledgeSvr_ServiceDesc is the grpc.ServiceDesc for KnowledgeSvr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KnowledgeSvr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "turingera.server.knowledge.KnowledgeSvr",
	HandlerType: (*KnowledgeSvrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetKnowledgeList",
			Handler:    _KnowledgeSvr_GetKnowledgeList_Handler,
		},
		{
			MethodName: "SaveKnowledge",
			Handler:    _KnowledgeSvr_SaveKnowledge_Handler,
		},
		{
			MethodName: "RemKnowledge",
			Handler:    _KnowledgeSvr_RemKnowledge_Handler,
		},
		{
			MethodName: "LoadKnowledge",
			Handler:    _KnowledgeSvr_LoadKnowledge_Handler,
		},
		{
			MethodName: "SearchKnowledge",
			Handler:    _KnowledgeSvr_SearchKnowledge_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "knowledge.proto",
}
